#!/bin/sh

# Copyright (C) 2011 Dejan Muhamedagic <dmuhamedagic@suse.de>
# 
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public
# License as published by the Free Software Foundation; either
# version 2.1 of the License, or (at your option) any later version.
# 
# This software is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# General Public License for more details.
# 
# You should have received a copy of the GNU General Public
# License along with this library; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
#

# WARNING:
#
# The CIB secrets interface and implementation is still being
# discussed, it may change

#
# cibsecret: manage the secrets directory /var/lib/heartbeat/lrm/secrets
#
# secrets are ascii files, holding just one value per file:
# /var/lib/heartbeat/lrm/secrets/<rsc>/<param>
#
# NB: this program depends on utillib.sh
#

. @OCF_ROOT_DIR@/resource.d/heartbeat/.ocf-shellfuncs

HA_NOARCHBIN=@datadir@/@PACKAGE_NAME@

. $HA_NOARCHBIN/utillib.sh

LRM_CIBSECRETS=$HA_VARLIB/lrm/secrets

PROG=`basename $0`

usage() {
	cat<<EOF
usage: $PROG <command> <parameters>

command: set | delete | stash | unstash | get | check | sync

	set <rsc> <param> <value>
	get <rsc> <param>
	check <rsc> <param>
	stash <rsc> <param>
	unstash <rsc> <param>
	delete <rsc> <param>
	sync

stash/unstash: move the parameter from/to the CIB (if you already
	have the parameter set in the CIB).

set/delete: add/remove a parameter from the local file.

get: display the parameter from the local file.

check: verify MD5 hash of the parameter from the local file and the CIB.

sync: copy $LRM_CIBSECRETS to other nodes.

Examples:

	$PROG set ipmi_node1 passwd SecreT_PASS
	$PROG stash ipmi_node1 passwd
	$PROG get ipmi_node1 passwd
	$PROG check ipmi_node1 passwd
	$PROG sync
EOF
	exit $1
}
fatal() {
	echo "ERROR: $*"
	exit 1
}
warn() {
	echo "WARNING: $*"
}
info() {
	echo "INFO: $*"
}

check_env() {
	which md5sum >/dev/null 2>&1 ||
		fatal "please install md5sum to run $PROG"
	which pssh >/dev/null 2>&1 ||
		which pdsh >/dev/null 2>&1 ||
		which ssh >/dev/null 2>&1 ||
		fatal "please install pssh, pdsh, or ssh to run $PROG"
	ps -ef | grep '[c]rmd' >/dev/null ||
		fatal "pacemaker not running? $PROG needs pacemaker"
}

get_other_nodes() {
	crm_node -l | awk '{print $2}' | grep -v `uname -n`
}
check_down_nodes() {
	local n down_nodes
	down_nodes=`(for n; do echo $n; done) | sort | uniq -u`
	if [ -n "$down_nodes" ]; then
		warn "nodes $down_nodes are down"
		warn "you'll need to update them using $PROG sync later"
	fi
}

# TODO: this procedure should be replaced with csync2
# provided that csync2 has already been configured
sync_files() {
	local crm_nodes=`get_other_nodes`
	local nodes=`get_live_nodes $crm_nodes`
	check_down_nodes $nodes $crm_nodes
	[ "$nodes" = "" ] && {
		info "no other nodes live"
		return
	}
	info "syncing $LRM_CIBSECRETS to `echo $nodes` ..."
	if which pssh >/dev/null 2>&1; then
		pssh -H "$nodes" rm -rf $LRM_CIBSECRETS
		pssh -H "$nodes" mkdir -p `dirname $LRM_CIBSECRETS`
		pscp -H "$nodes" -x "-pr" $LRM_CIBSECRETS `dirname $LRM_CIBSECRETS`
	elif which pdsh >/dev/null 2>&1; then
		local pdsh_nodes=`echo $nodes | tr ' ' ','`
		pdsh -w $pdsh_nodes rm -rf $LRM_CIBSECRETS
		pdsh -w $pdsh_nodes mkdir -p `dirname $LRM_CIBSECRETS`
		pdcp -pr -w $pdsh_nodes $LRM_CIBSECRETS `dirname $LRM_CIBSECRETS`
	else
		local h
		for h in $nodes; do
			ssh $h rm -rf $LRM_CIBSECRETS
			ssh $h mkdir -p `dirname $LRM_CIBSECRETS`
			scp -pr -q $LRM_CIBSECRETS $h:`dirname $LRM_CIBSECRETS`
		done
	fi
}
sync_one() {
	local f=$1
	local crm_nodes=`get_other_nodes`
	local nodes=`get_live_nodes $crm_nodes`
	check_down_nodes $nodes $crm_nodes
	[ "$nodes" = "" ] && {
		info "no other nodes live"
		return
	}
	info "syncing $f to `echo $nodes` ..."
	if which pssh >/dev/null 2>&1; then
		pssh -H "$nodes" mkdir -p `dirname $f`
		if [ -f "$f" ]; then
			pscp -H "$nodes" -x "-p" $f `dirname $f`
		else
			pssh -H "$nodes" rm -f $f
		fi
	elif which pdsh >/dev/null 2>&1; then
		local pdsh_nodes=`echo $nodes | tr ' ' ','`
		pdsh -w $pdsh_nodes mkdir -p `dirname $f`
		if [ -f "$f" ]; then
			pdcp -p -w $pdsh_nodes $f `dirname $f`
		else
			pdsh -w $pdsh_nodes rm -f $f
		fi
	else
		local h
		for h in $nodes; do
			ssh $h mkdir -p `dirname $f`
			if [ -f "$f" ]; then
				scp -p -q $f $h:`dirname $f`
			else
				ssh $h rm -f $f
			fi
		done
	fi
}

is_secret() {
	echo $1 | grep "^$MAGIC:" >/dev/null
}
check_cib_rsc() {
	local rsc=$1 output
	output=`$NO_CRM crm resource show $rsc >/dev/null 2>&1` ||
		fatal "resource $rsc doesn't exist: $output"
}
get_cib_param() {
	local rsc=$1 param=$2
	check_cib_rsc $rsc
	$NO_CRM crm resource param $rsc show $param 2>/dev/null
}
set_cib_param() {
	local rsc=$1 param=$2 value=$3
	check_cib_rsc $rsc
	$NO_CRM crm resource param $rsc set $param "$value" 2>/dev/null
}
remove_cib_param() {
	local rsc=$1 param=$2
	check_cib_rsc $rsc
	$NO_CRM crm resource param $rsc delete $param 2>/dev/null
}

localfiles() {
	local cmd=$1
	local rsc=$2 param=$3 value=$4
	local local_file=$LRM_CIBSECRETS/$rsc/$param
	case $cmd in
	"get")
		cat $local_file 2>/dev/null
		true
		;;
	"set")
		mkdir -p `dirname $local_file` &&
			echo $value > $local_file &&
			sync_one $local_file
		;;
	"remove")
		rm -f $local_file
		sync_one $local_file
	;;
	*)
		# not reached, this is local interface
	;;
	esac
}
get_local_param() {
	local rsc=$1 param=$2
	localfiles get $rsc $param
}
set_local_param() {
	local rsc=$1 param=$2 value=$3
	localfiles set $rsc $param $value
}
remove_local_param() {
	local rsc=$1 param=$2
	localfiles remove $rsc $param
}

cibsecret_set() {
	local md5sum
	local value=$1

	md5sum=`printf $value | md5sum` ||
		fatal "md5sum failed to produce hash for resource $rsc parameter $param"
	md5sum=`echo $md5sum | awk '{print $1}'`
	[ "$current" -a "$current" != "$value" ] &&
		info "overwriting CIB contents of resource $rsc parameter $param"
	set_local_param $rsc $param $value &&
	set_cib_param $rsc $param "$MAGIC:$md5sum"
}

cibsecret_get() {
	if [ "$current_local" != "" ]; then
		echo "$current_local"
	else
		exit 1
	fi
}

cibsecret_check() {
	local md5sum
	is_secret "$current" ||
		fatal "no MD5 hash in CIB for resource $rsc parameter $param"
	md5sum=`printf "$current_local" | md5sum | awk '{print $1}'`
	[ "$current" == "$MAGIC:$md5sum" ] ||
		fatal "MD5 hash mismatch for resource $rsc parameter $param"
}

cibsecret_delete() {
	remove_local_param $rsc $param &&
	remove_cib_param $rsc $param
}

cibsecret_stash() {
	[ "$current" = "" ] &&
		fatal "nothing to stash for resource $rsc parameter $param"
	is_secret "$current" &&
		fatal "CIB value for resource $rsc parameter $param already MD5 hash"
	cibsecret_set "$current"
}

cibsecret_unstash() {
	[ "$current_local" = "" ] &&
		fatal "nothing to unstash for resource $rsc parameter $param"
	is_secret "$current" ||
		warn "no MD5 hash in CIB for resource $rsc parameter $param, proceeding anyway"
	remove_local_param $rsc $param &&
	set_cib_param $rsc $param $current_local
}

cibsecret_sync() {
	sync_files
}

check_env

MAGIC="SecretMD5"
umask 0077

cmd=$1
rsc=$2
param=$3
value=$4

case "$cmd" in
	set) [ $# -ne 4 ] && usage 1;;
	get) [ $# -ne 3 ] && usage 1;;
	check) [ $# -ne 3 ] && usage 1;;
	stash) [ $# -ne 3 ] && usage 1;;
	unstash) [ $# -ne 3 ] && usage 1;;
	delete) [ $# -ne 3 ] && usage 1;;
	sync) [ $# -ne 1 ] && usage 1;;
	*) usage 1;
esac

# we'll need these two often
current=`get_cib_param $rsc $param`
current_local=`get_local_param $rsc $param`

cibsecret_$cmd $value
